"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.entropyToPhrase = exports.phraseToEntropy = void 0;
const wordlist_en_1 = __importDefault(require("./wordlist_en"));
const react_native_sha256_1 = require("react-native-sha256");
const buffer_1 = require("buffer");
const normalize = (str = "") => {
    return str.normalize("NFKD");
};
const lpad = (str, padString, length) => {
    while (str.length < length) {
        str = padString + str;
    }
    return str;
};
const binaryToByte = (bin) => {
    return parseInt(bin, 2);
};
const bytesToBinary = (bytes) => {
    return bytes.map((x) => lpad(x.toString(2), "0", 8)).join("");
};
const deriveChecksumBits = async (entropyBuffer) => {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const hash = await (0, react_native_sha256_1.sha256Bytes)(Array.from(entropyBuffer));
    return bytesToBinary(Array.from(buffer_1.Buffer.from(hash, "hex"))).slice(0, CS);
};
const INVALID_MNEMONIC = "Invalid mnemonic";
const INVALID_ENTROPY = "Invalid entropy";
const INVALID_CHECKSUM = "Invalid mnemonic checksum";
const phraseToEntropy = async (mnemonic, wordlist = wordlist_en_1.default) => {
    const words = normalize(mnemonic).split(" ");
    if (words.length % 3 !== 0) {
        throw new Error(INVALID_MNEMONIC);
    }
    // convert word indices to 11 bit binary strings
    const bits = words
        .map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
            throw new Error(INVALID_MNEMONIC);
        }
        return lpad(index.toString(2), "0", 11);
    })
        .join("");
    // split the binary string into ENT/CS
    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex);
    // calculate the checksum and compare
    const entropyBytes = entropyBits.match(/(.{1,8})/g)?.map(binaryToByte) || [];
    if (entropyBytes.length < 16) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length > 32) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length % 4 !== 0) {
        throw new Error(INVALID_ENTROPY);
    }
    const entropy = buffer_1.Buffer.from(entropyBytes);
    const newChecksum = await deriveChecksumBits(entropy);
    if (newChecksum !== checksumBits) {
        throw new Error(INVALID_CHECKSUM);
    }
    return entropy.toString("hex");
};
exports.phraseToEntropy = phraseToEntropy;
const entropyToPhrase = async (entropy, wordlist = wordlist_en_1.default) => {
    if (typeof entropy === "string") {
        entropy = buffer_1.Buffer.from(entropy, "hex");
    }
    // 128 <= ENT <= 256
    if (entropy.length < 16) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length > 32) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length % 4 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    const entropyBits = bytesToBinary(Array.from(entropy));
    const checksumBits = await deriveChecksumBits(entropy);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    if (!chunks) {
        throw new TypeError(INVALID_ENTROPY);
    }
    const words = chunks.map((binary) => {
        const index = binaryToByte(binary);
        return wordlist[index];
    });
    return words.join(" ");
};
exports.entropyToPhrase = entropyToPhrase;
