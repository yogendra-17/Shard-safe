import { Buffer } from 'buffer';
import BN from 'bn.js';
//@ts-ignore
import { randomBytes } from 'react-native-randombytes';
function mul_gf2(f1, f2) {
    if (f2.gt(f1)) {
        let temp = f1;
        f1 = f2;
        f2 = temp;
    }
    let z = new BN.BN(0, 10);
    while (!f2.isZero()) {
        if (!f2.and(new BN.BN(1, 10)).isZero()) {
            z = z.xor(f1);
        }
        f1 = f1.shln(1);
        f2 = f2.shrn(1);
    }
    return z;
}
function div_gf2(a, b) {
    if (a.lt(b)) {
        return { q: new BN.BN(0, 10), r: a };
    }
    let q = new BN.BN(0, 10), r = a, deg_b = b.bitLength(), s;
    while (r.bitLength() >= deg_b) {
        s = new BN.BN(1, 10).shln(r.bitLength() - deg_b);
        q = q.xor(s);
        r = r.xor(mul_gf2(b, s));
    }
    return { q: q, r: r };
}
class Element {
    constructor(encoded_val) {
        this.irr_poly = new BN.BN(1, 10)
            .add(new BN.BN(2, 10).pow(new BN.BN(2, 10)))
            .add(new BN.BN(2, 10).pow(new BN.BN(5, 10)))
            .add(new BN.BN(2, 10).pow(new BN.BN(8, 10)))
            .add(new BN.BN(2, 10).pow(new BN.BN(512, 10)));
        this.val = encoded_val;
    }
    _int() {
        return this.val;
    }
    equals(gf_val) {
        return this.val.eq(gf_val._int());
    }
    _encode() {
        if (this.val.toString(16).length % 2)
            return Buffer.from('0' + this.val.toString(16), 'hex');
        return Buffer.from(this.val.toString(16), 'hex');
    }
    _mul(fac) {
        let f1 = this.val;
        let f2 = fac.val;
        if (f2.gt(f1)) {
            [f1, f2] = [f2, f1];
        }
        if (this.irr_poly == f1 || this.irr_poly == f2) {
            return new Element(new BN.BN(0, 10));
        }
        let mask1 = new BN.BN(2, 10).pow(new BN.BN(512, 10)), [v, z] = [f1, new BN.BN(0, 10)], mask2, mask3;
        while (!f2.isZero()) {
            mask2 = new BN.BN(f2.and(new BN.BN(1, 10)).toString(2).repeat(512), 2);
            z = mask2.and(z.xor(v)).or(mask1.sub(mask2).sub(new BN.BN(1, 10)).and(z));
            v = v.shln(1);
            mask3 = new BN.BN(v.shrn(512).and(new BN.BN(1, 10)).toString(2).repeat(512), 2);
            v = mask3
                .and(v.xor(this.irr_poly))
                .or(mask1.sub(mask3).sub(new BN.BN(1, 10)).and(v));
            f2 = f2.shrn(1);
        }
        return new Element(z);
    }
    _add(term) {
        return new Element(this.val.xor(term.val));
    }
    inverse() {
        if (this.val.isZero()) {
            throw 'Inversion of zero is not defined!';
        }
        let r0, r1, s0, s1, q, temp1, temp2;
        r0 = this.val;
        r1 = this.irr_poly;
        s0 = new BN.BN(1, 10);
        s1 = new BN.BN(0, 10);
        while (r1.gt(new BN.BN(0, 10))) {
            q = div_gf2(r0, r1).q;
            temp1 = r1;
            r1 = r0.xor(mul_gf2(q, r1));
            r0 = temp1;
            temp2 = s1;
            s1 = s0.xor(mul_gf2(q, s1));
            s0 = temp2;
        }
        return new Element(s0);
    }
    _pow(exp) {
        let res = new Element(this.val);
        for (let _ = 0; _ < exp - 1; _++) {
            res = res._mul(this);
        }
        return res;
    }
}
const make_share = (user, coeffs) => {
    let idx = new Element(user);
    let share = new Element(new BN.BN(0, 10));
    for (let i = 0; i < coeffs.length; i++) {
        share = idx._mul(share)._add(coeffs[i]);
    }
    return share._encode();
};
export const split = async (n, k, sec) => {
    let coeff = [], secret;
    secret = Buffer.from(sec, 'hex');
    // if (secret.length != 16 && secret.length != 32) {
    //   throw new Error('Secret should be 32 byte or 16 byte!');
    // }
    for (let i = 0; i < k - 1; i++) {
        const rnb = await randomBytes(64);
        coeff.push(new Element(new BN(rnb.toString('hex'), 16)));
    }
    coeff.push(new Element(new BN(secret)));
    let res = [];
    for (let i = 1; i < n + 1; i++) {
        let share = make_share(new BN.BN(i, 10), coeff).toString('hex');
        res.push({ x: new BN.BN(i, 10), y: share });
    }
    return res;
};
export const join = (shares) => {
    let k = shares.length, gf_shares = [], idx, val, result;
    for (let i = 0; i < shares.length; i++) {
        let z = new BN.BN(shares[i].x, 16);
        idx = new Element(z);
        val = new Element(new BN(Buffer.from(shares[i].y, 'hex')));
        gf_shares.push([idx, val]);
    }
    result = new Element(new BN.BN(0, 10));
    let x_j, y_j, num, den;
    for (let j = 0; j < k; j++) {
        [x_j, y_j] = [gf_shares[j][0], gf_shares[j][1]];
        num = new Element(new BN.BN(1, 10));
        den = new Element(new BN.BN(1, 10));
        for (let m = 0; m < k; m++) {
            let x_m = gf_shares[m][0];
            if (m != j) {
                num = num._mul(x_m);
                den = den._mul(x_j._add(x_m));
            }
        }
        result = result._add(y_j._mul(num)._mul(den.inverse()));
    }
    return result._encode().toString('hex');
};
